
// Tyler Manifold

// HuffmanTree.cpp

#include "HuffmanTree.h"
#include <algorithm>
#include <iostream>
#include <fstream>

HuffmanTreeNode::HuffmanTreeNode()
{
	this->_key = "";
	this->_value = 0;
}

HuffmanTreeNode::HuffmanTreeNode(string k, int v)
{
	this->_key = k;
	this->_value = v;
}

// copy the attributes from the given node h into this node
HuffmanTreeNode::HuffmanTreeNode(HuffmanTreeNode* h)
{
	this->_key = h->_key;
	this->_value = h->_value;

	this->_left = h->_left;
	this->_right = h->_right;
}

// getter for key
string HuffmanTreeNode::key()
{
	return this->_key;
}

// setter for key
void HuffmanTreeNode::key(string s)
{
	this->_key = s;
}

// getter for value
int HuffmanTreeNode::value()
{
	return this->_value;
}

// setter for value
void HuffmanTreeNode::value(int v)
{
	this->_value = v;
}

// getter for left node
HuffmanTreeNode* HuffmanTreeNode::left()
{
	return this->_left;
}

string HuffmanTreeNode::encoding()
{
	return this->_code;
}

void HuffmanTreeNode::encoding(string s)
{
	this->_code = s;
}

// setters for left node
void HuffmanTreeNode::left(HuffmanTreeNode* n)
{
	this->_left = n;
}

void HuffmanTreeNode::left(string k, int v)
{
	this->_left = new HuffmanTreeNode(k, v);
}

// getter for right node
HuffmanTreeNode* HuffmanTreeNode::right()
{
	return this->_right;
}

// setters for right node
void HuffmanTreeNode::right(string k, int v)
{
	this->_right = new HuffmanTreeNode(k, v);
}

void HuffmanTreeNode::right(HuffmanTreeNode* n)
{
	this->_right = n;
}

// ---- END HuffmanTreeNode member functions ----


// ---- BEGIN HuffmanTree member functions ----

HuffmanTree::HuffmanTree()
{
	this->root = new HuffmanTreeNode();
}

HuffmanTree::HuffmanTree(vector<tuple<string, int>>* data)
{
	this->root = new HuffmanTreeNode();

	std::cout << "initializing nodes.\n";
	this->init_nodes(data);

	std::cout << "\nbuilding tree.\n";
	this->make_tree();

	std::cout << "\nprinting sideways.\nroot node is displayed leftmost.\n";
	this->print(this->root, 0);

	std::cout << "\nencoding leaves.\n";
	this->init_assign_codes();

	std::cout << "\nsorting encoded leaves by ASCII value.\n";
	std::sort(codetable.begin(), codetable.end(),
		[](tuple<string, string> a, tuple<string,string> b) {
		
			int achar = 0;
			int bchar = 0;

			if (std::get<0>(a) == "LF")
				achar = 10;
			else
				achar = std::get<0>(a)[0];
			

			if (std::get<0>(b) == "LF")
				bchar = 10;
			else
				bchar = std::get<0>(b)[0];
			

			return achar < bchar;
		});

	for (int i = 0; i < codetable.size(); i++)
	{
		std::cout << std::get<0>(codetable.at(i)) << " " << std::get<1>(codetable.at(i)) << std::endl;
	}
}

/* init_nodes
	Convert a vector of <string,int> tuples into a vector HuffmanTreeNode pointers
	this will make processing the key-value pairs into a binary tree much easier
*/
void HuffmanTree::init_nodes(vector<tuple<string, int>>* data)
{
	this->nodes = new vector<HuffmanTreeNode*>();

	for (int i = 0; i < data->size(); i++)
	{
		this->nodes->push_back(
			new HuffmanTreeNode(std::get<0>(data->at(i)), std::get<1>(data->at(i)))
		);
	}
}

/* make_tree
	Build the tree out of nodes vector generated by init_nodes
*/
void HuffmanTree::make_tree()
{
	// loop until only one node is remaining in the list, i.e., the tree has been completed
	while (this->nodes->size() != 1)
	{
		// create a new intermediary node by adding the front two nodes together
		int inode_val = this->nodes->at(0)->value() + this->nodes->at(1)->value();

		HuffmanTreeNode* N = new HuffmanTreeNode( "", inode_val );

		// set the nodes that were added together as left and right of N
		// remove nodes from the list after adding them to the tree
		HuffmanTreeNode* L = new HuffmanTreeNode(this->nodes->at(0));
		N->left(L);
		this->nodes->erase(this->nodes->begin());

		HuffmanTreeNode* R = new HuffmanTreeNode(this->nodes->at(0));
		N->right(R);
		this->nodes->erase(this->nodes->begin());		

		// insert N into the list

		this->nodes->push_back(N);

		// reorder by top node value
		this->reorder();

		//for (int i = 0; i < this->nodes->size(); i++)
		//	std::cout << this->nodes->at(i)->value() << " ";
		//std::cout << std::endl;
	}

	this->root = this->nodes->at(0);
}

// reorder the list after combining nodes into a subtree
void HuffmanTree::reorder()
{
	std::sort(this->nodes->begin(), this->nodes->end(),
		[](HuffmanTreeNode a, HuffmanTreeNode b) {
			return (a.value() < b.value());
		});
}

void HuffmanTree::init_assign_codes()
{
	if (this->root->left())
		this->assign_codes(root->left(), "0");

	if (this->root->right())
		this->assign_codes(root->right(), "1");
}

// recursively walk the tree until a leaf is reached, assign a code based on left- and right-depth
void HuffmanTree::assign_codes(HuffmanTreeNode* n, string code)
{
	if (!n->left() && !n->right())
	{
		n->encoding(code);
		std::cout << __func__ << ": " << n->key() << " -- " << n->encoding() << std::endl;

		codetable.emplace_back(n->key(), n->encoding());
	}
	//else 
	//{
	//	if (n->left())
	//		this->assign_codes(n->left(), code.append("0"));

	//	if (n->right())
	//		this->assign_codes(n->right(), code.append("1"));
	//}
	else
	{
		// normally we would do a sanity check for left and right existing individually,
		// but the tree is structured such that each node has either 2 or 0 child nodes
		
		string l = code;
		string r = code;
		this->assign_codes(n->left(), l.append("0"));
		this->assign_codes(n->right(), r.append("1"));
	}
}

// print the tree sideways, with the right-most node displayed at the top
void HuffmanTree::print(HuffmanTreeNode* n, int depth = 0)
{
	depth += 8;

	if (n != nullptr)
	{
		this->print(n->right(), depth);

		for (int i = 0; i < depth; i++)
		{
			std::cout << " ";
		}

		std::cout << "(" << n->key() << "," << n->value() << ")\n";

		this->print(n->left(), depth);
	}
}
